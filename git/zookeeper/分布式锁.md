1.为什么需要锁？
    JDK锁

    1.多任务环境中才需要
    2.任务都需要对同一个共享资源进行写操作
    3.对资源的访问是互斥的
    满足这三个条件才会用到锁

    任务通过竞争获取锁，才能对资源进行操作（竞争锁）
    当有一个任务在对资源进行更新时（占有锁）
    其他任务都不可以对这个资源进行操作（任务阻塞）
    知道该任务完成更新（释放锁）

    锁的生命周期是不断循环的，竞争锁，占有锁，任务阻塞，释放锁，直到任务完成

线程安全的问题都是由类变量，或者静态变量引起的
类变量堆里面
静态变量在1.8之前叫方法区里面，1.8之后叫元空间
在这两个区里面的数据是线程共享的数据
对这种共享资源进行写操作时，不加控制容易出事
Lock
    try catch finally
unlock

JVM锁解决一个进程内不同线程之间争夺资源的问题，解决不了分布式环境多任务对共享资源竞争的协同操作问题

2.分布式锁方案
    1.基于数据库mysql
    思路：利用数据库自身提供的锁机制实现，要求数据库支持行级锁
    优点：简单，稳定
    缺点：性能差，无法适应高并发场景，容易出现死锁，无法优雅的实现阻塞式锁

    2.基于redis
    思路：保证缓存操作序列的原子性
    优点：性能好
    缺点：实现相对较复杂，有可能出现死锁，无法优雅实现阻塞式锁

    3.基于zookeeper
    思路：基于zk的节点特性以及watch机制实现
    优点：性能好，稳定可靠性高，较好的实现阻塞式锁
    缺点：实现相对复杂

zookeeper内存级别的








3.基于zookeeper的实现
zookeeper，分布式协调服务，讲那些复杂且容易出错的分布式一致性服务封装起来，以简单易用的接口提供给用户

zookeeper的特性：
1.在内存中维护一个具有层次关系的数据结构，类似于一个标准的文件系统
2.数据节点（Znode）：数据结构中的每个节点都可以存数据，还有各种属性信息
    数据节点有：持久节点
                持久顺序节点
                临时节点
                临时顺序节点




从设计角度理解，基于观察者模式，负责存储和管理大家都关心的数据，一旦这些数据的状态发生变化，zookeeper就将负责通知已经在zookeeper上注册的那些观察者做出相应的反应
zookeeper=文件系统+通知机制
zookeeper：一个leader，多个follower
集群中只要有半数以上节点存活，zookeeper集群就可以正常服务
全局一致性：每个server保存一份相同的数据副本，client无论链接到哪个server数据都是一致的
更新请求顺序进行，针对同一个client
数据更新原子性，一次数据更新要么成功要么失败
实时性，在一定时间范围内，client能读到最新的数据

数据结构：树形结构，每个节点叫做一个ZNode，每个ZNode默认存储1MB的数据，每个ZNode都可以通过其路径唯一标识

应用场景：
    统一命名：分布式环境下，经常需要对应用/服务进行统一命名，便于识别

    统一配置管理：配置文件同步
    对配置文件修改后，希望能够快速同步到各个节点上
    
    将配置信息写入zookeeper的一个znode
    各个客户端服务器监听这个Znode
    一旦Znode中的数据被修改，zookeeper将通知各个客户端服务器

    同一集群管理
    1.分布式环境中，实时掌握每个节点的状态是必要的
    2.zookeeper可以实现实时监控节点状态变化
    

    服务器节点动态上下线
    只要一变化，立即通知
    发现服务器挂了，client就去访问别的
    

    负载均衡
    在zookeeper中国记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求

如何启动zookeeper
1.先启动服务
2.再启动客户端


配置参数解读
tickTime  心跳
initLimit leader和follower通信时长启动时，如果超过这个时长，就认为连接断开
synclimit leader和follower通信时长启动之后
dataDir：存储数据的地方


内部原理：
1.选举机制
    1.半数机制：集群中半数以上机器存活，集群可用。所以zookeeper适合安装奇数台服务器
    2.leader通过内部选举机制临时产生的
    3.id_1启动后的状态是looking，id_2启动后与1进行通信，id比较大的胜出，但是如果没有超过半数，id2来了投自己，1也投2，因为2，id号大
    leader占了坑后，id大也不管用
    每个服务器上来先选自己，选自己不行了，选id号大的


节点类型
持久节点：客户端和服务器断开后，创建的节点不删除
临时节点：客户端与服务器断开后，创建的节点自己删除

持久化目录节点：客户端与zookeeper断开连接后，该节点依旧存在
持久化顺序编号目录节点：客户端与zookeeper断开连接后，该节点依旧存在，zookeeper会给该节点名称进行顺序编号
顺序号，从0开始，单调递增的计数器，由父节点维护
顺序号可用于对所有事件进行全局排序，这样客户端可以通过顺序号推断时间的顺序

临时目录节点：最适合服务器动态上下线场景
临时顺序编号目录节点：


create -e 创建临时节点
        -s 加序号
修改节点值：set
监听，注册一次有效一次，再监听，再注册
删除 delete
递归删除：rmr

zookeeper面试真题
1.请描述zookeeper的选举机制
2.zookeeper的监听原理
3.zookeeper的部署方式？
4.zookeeper的常用命令


监听器原理：
1.首先要有main线程
2.在main线程中创建zookeeper客户端，这是就会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）
3.通过connect线程将注册的监听事件发送给zookeeper
getChildren("/" ,true) true表示开启监听
4.在zookeeper的监听器列表中将注册的监听事件添加到列表中
5.zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程
6.接收到变化之后，listener线程内部调用process方法，这个process方法就是程序员要实现的

常见的监听
1.监听节点数据的变化
    get path[watch]
2.监听子节点增减的变化
    ls path[watch]


写数据流程：
1.client向zookeeper的server1上写数据，发送一个写请求
2.如果server1不是leader，那么server1会把接收到的请求进一步转发给leader，leader会将写请求转发给各个serer，各个server写成功后会通知leader
3.当leader收到大多数server数据写成功了，就说明数据写成功，一半以上，leader就会告诉server1数据写成功了
4.server1就会进一步通知client数据写成功了
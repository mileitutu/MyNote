1.JVM的永久代中会发生垃圾回收么？
永生代也是可以回收的，条件是 1.该类的实例都被回收。 2.加载该类的classLoader已经被回收 3.该类不能通过反射访问到其方法，而且该类的java.lang.class没有被引用 当满足这3个条件时，是可以回收，但回不回收还得看jvm。

2.Java中的两种异常类型是什么？他们有什么区别？
RuntimeException类及其子类
这些异常是不检查的异常, 是在程序运行的时候可能会发生的, 所以程序可以捕捉, 也可以不捕捉. 这些错误一般是由程序的逻辑错误引起的, 程序应该从逻辑角度去尽量避免.
检查异常是运行时异常以外的异常, 也是Exception及其子类, 这些异常从程序的角度来说是必须经过捕捉检查处理的, 否则不能通过编译. 如IOException、SQLException等

3.进程和线程的区别
进程是资源分配的最小单位，线程是cpu调度的最小单位
进程是抢占处理机的调度单位线程属于某个进程，共享其资源

线程不能看做独立应用，进程可以看做独立应用
进程有独立的地址空间，进程间相互不影响，线程只是进程的不同的执行路径
线程没有独立的地址空间，多进程的程序比多线程的程序健壮
进程切换比线程切换开销大
运行一个程序会产生一个进程，进程包含至少一个线程
每一个进程对应一个JVM实例，多个线程共享JVM里的堆
java采取单线程编程模型，程序会自动创建主线程
主线程可以创建子线程，通常因为要完成各种关闭动作，主线程最后完成执行

4.Thread中的start和run的区别
调用start方法，会创建一个新的子线程并启动
run方法只是Thread的一个普通方法的调用

5.Thread和Runnable的区别
Thread是实现了Runnable接口的类，使得run支持多线程
因为类的单一继承原则， 推荐使用Runnable接口


6.线程的状态？
    1.新建:创建后尚未启动的线程的状态
    2.运行：包含running和ready
    3.无限期等待：不会被分配CPU执行时间，需要显式被唤醒
        没有设置TimeOut参数的Object.wait()
        没有设置TimeOut参数的Thread.join()
        调用了LockSupport.park()
    4.限期等待：在一定时间后会由系统自动唤醒
        设置TimeOut参数的Object.wait()
        设置TimeOut参数的Thread.join()
    5.阻塞：等待获取排它锁
    6.结束：已终止线程的状态，线程已经结束执行，已终止线程不能复生，调用start会报错

7.sleep和wait的区别
sleep是Thread类的方法，wait是Object类中定义的方法
sleep方法可以在任何地方使用
wait方法只能在synchronized方法或者synchronized块中使用
Thread。sleep